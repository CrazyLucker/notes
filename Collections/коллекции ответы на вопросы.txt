Что такое генерики?
Дженерик это возможность не указывать точный тип данных который будет
использоваться. Стираются при компиляции. Сделаны для предохранения программиста от путаницы в типах данных и создания более гибкого API.

===============================================================

Типы генериков?
Существует 2 типа дженериков:
1. Параметризированый тип
Представляет из себя возможность указать неопределенный тип, или несколько(в классе или методе), и дать ему имя котрое в дальнейшем может использоваться в рамках класса, или метода, как эквивалентное оригинальному типу. Может быть использован с ключевым словом extends, что будет озночать, что выбор класса который может быть использован в данном месте, ограничен этим классом и его наследниками. Так же можно использовать & или/и | указать несколько классов и/или интерфейсов.
Поддерживает рекурсивное расширение типов
2. Wildcard
Используется в сигнатуре методов. Для параметризации класса - не возможно.
Может быть использован в сочитании ключевыми словами extends и/или
super. Пишется как "?". Для правильного использования Wildcard этими ключевыми словами есть принцип PECS (Producer - extends, Consumer - super). Тоесть если нам надо только получать данные из объекта то мы используем слово extends, а если надо записать в объект данные то - super. 
Рекурсивные дженерики?????

===============================================================
Где храниться информация про генерики?
Только в исходном коде до момента компиляции.
===============================================================
Как можно получить тип генерика?
.getGenericSuperclass()
Class<T> t = (Class<T>) ((ParameterizedType) getClass().getGenericSuperclass()).getActualTypeArguments()[0];
===============================================================
Что такое итератор?
Это шаблон проектирования для прохода по всем элементам множества характерен 2мя методами: hasNext() - существует ли следующий элемент и next() - возвращает сам элемет, для реализации в стандартной библиотеке java существует 2 интерфейса это Iterable и Iterator. 
Iterable - вынуждает релизовать метод возвращающий итератор.
А Iterator - вернуть объект итератора.
===============================================================
Что такое коллекции?
Множества с динамическим размером, и разным временем на разные операции:
поиск, вставка, удаление.
===============================================================
Назовите базовые интерфейсы коллекций?
Collection и Map разделяют все коллекции по способам хранения данных в множестве. Либо просто сзачение либо ключь-значение.
===============================================================
Расскажите реализации интерфейса List?
ArrayList - на массиве с несинхронизированными методами.
Vector - на массиве с синхронизированными методами.
Stack - на массиве есть синхронизированные методы но не все.
LinkedList - двусвязный список. 
===============================================================
Расскажите реализации интерфейса Set?
Set не может содержать дубликаты.

HashSet - основан на HashMap.
LinkedHashSet - расширяет HashSet, позволяет получать элементы в порядке их добавления, но требует больше памяти.
TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов. Можно управлять порядком при помощи компаратора.
===============================================================
Расскажите реализации интерфейса Map?
Hashtable - синхронизированная хэш-таблица (медленная).
HashMap - не синхронизированная хэш-таблица (быстрая).
LindedHashMap - упоряодченная хэш-таблица с порядом итерирования в порядке добавления.
TreeMap - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе. 
===============================================================
Отличие ArrayList от LinkedList?
Массив - связный список
===============================================================
Отличие Set от List?
Set не хранит дубликаты. List - хранит.
===============================================================
Расскажите про методы Object hashCode и equals?
Метод hashCode используется для числового представления объекта, метод equals для сравнения двух объектов.
При переопределении метода equals всегда переопределяют hashCode.
Если метод equals true то hashCode всегда равны, но не наоборот, потому что возможны 
коллизии и для разных элементов будет одинаковый hashCode.

Метод equals переопределяется так: 
1. Не равны ли ссылки
2. Не равен null
3. Проверяем что объекты от одного класса.
4. Не равны ли hashCode
5. Не равны состояния полей.

Метод HashCode переопределяется так:
1. Простое нечетное число (31 популярно)
2. Умножаем результат на другое простое нечетное число (популярно 17) прибавляем hashCode поля которое относится к бизнес логике.
3. Повторяем пункт 2 пока не кончатся поля которые относятся к бизнес логике.
===============================================================
Расскажите, что такое коллизии в Map? Как с ними бороться?
Коллизия это когда для двух объектов вычисляется одинаковый хеш код. Решение это проверить методом equals что ссылки на объекты не равны, и в случае с хэш-таблицей добавить в ту же ячейку еще один объект, за счет того что в каждая ячейка это связанный список.
===============================================================
Расскажите, что такое анализ алгоритма?
Это то как соотносится колличество данных с скоростью работы алгоритма.
O(1)-константное время, O(log(n)) , O(n) - линейное
===============================================================
Какая про время работы методов добавление и получение данных в различных структурах данных. 
С чем связаны отличия?
ArrayList: индекс - 0(1), поиск 0(n). вставка 0(n), удаление O(n).
LinkedList: индекс - 0(n), поиск 0(n). вставка 0(1), удаление O(1).
Деревья для всех операций - O(log(n)).
Хэш таблицы - O(1) для всех операций, если не считать коллизии
===============================================================
Расскажите реализации данных очередей и стеков.
Очередь(Queue одностороняя очередь) - когда элементы можно получить в том порядке в котором добавляли.
Двусторонняя очередь (Dequeue ) очередь, у которой нет явно выраженного конца и начала. Она может расти и уменьшаться в обоих направлениях.

Стек - можно получить только последний элемент
===============================================================
Расскажите про реализации деревьев.

TreeMap - Упорядоченная по ключам. Основана на красно-черных деревьях. Может использовать компаратов в конструкторе. Красно-черные деревья это самобалансирующееся дерево которое гарантирует логарифмический рост высоты дерева от числа узлов.

TreeSet - основан на сбалансированном двоичном дереве, в результате элементы упорядочены по возрастанию hashCode()'ов. Можно управлять порядком при помощи компаратора.
===============================================================
Что такое load factory?
В хеш таблице поле которое показывает на сколько заполнен массив на котором эта таблица основана, если на 3/4 то создается новый массив с большим размером и данные перераспределяются. Вычисляется длинна массива / колличество элементов.
