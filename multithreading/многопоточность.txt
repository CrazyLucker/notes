Процесс это Отдельно запущенное приложение и у него есть своя область памяти.(минимум 1 поток)
=======
Поток это паралельные нити выполнения внутри одного процесса которые разделяют общую память.
Поток это объект у которого есть 2 метода:
1)start(); вызывается другим потоком. У этого объекта будет выполнен метод run(); паралельно с тем потоком который вызвал метод  start();

Мы не знаем точное время когда будет запущен метод run() и за это отвечает OC.

 Есть 2 способа создать новые поток: 
 1)MyClass implements Runneble(можем наследоваться от классов)
 2)MyClass extends Thread (не сможем больше наследоваться от классов, но можем использовать методы Thread)
 И в том и в другом случае будет метод run(); и start();
 
 Некоторые методы:
 long getId()
 String getName()

 boolean isAlive()
 int getPriority()
 void setPriority()
 static void sleep(1000) - остановит на 1 сек.
 void interrupt() - можно разбудить поток из другого потока но вылетит исключение, если поток не засыпал то будет выставлен флаг interrupted.
 static boolean interrupted() - флаг который показывает не прервал ли кто нибудь этот поток.
 void join() - что-бы один поток ждал жругой. thread01.join() - thread01 будет выполняться и заставит ждать тот поток который этот вызов сделал.
Thread.currentThread() — статический метод, возвращающий объект потока, в котором он был вызван.

Mutex(Mutual exclusion) - протой двоичный Semaphore. (Вкл/Выкл)
Critical Section - участок кода к тоторому должен получить доступ только 1 поток.
Monitor - объект который следит за тем чтобы в критическую секцию попал только 1 поток и уведомляет о другие потоки о том что какой-то поток вышел из критической секции.
Semaphore - счетчик который ограничиват количество потоков которое может одновременно использовать какой-то участок кода.
Lock - механизм блокировки для организации Critical Section.

Race condition когда несколько потоков перезатерают одну переменную не зная друг о друге, из за того что присваивание нового значения переменной проходит в три этапа: чтение из памяти, обработка данных и запись в память. Проблема один поток уже обрабатывает другой только прочитал.

Visabilyty - когда поток считывает данные не извесно откуда и неизвесно куда он их запишет потому что он может читать и записывать результат вычисления в CPU Register, CPU Cash Memory, и только в случае если они переполнены он запишет все в heap. Кл. сл. volatile запрещает кэшировать переменную, она будет доступна только из heap и записываться только в heap.
=============
Взаимодействие потоков.
happy's baefore(если в одном потоке что-то случилось другой об этом знает)
Есть 2 решения:
№1. synchronized - не позволяет друм потокам одновременно заходить в метод.
class Exemple {
    boolean canWork = true;
    
    public synchronized void doWork() {
        if(canWork) {}
    }
    
    public synchronized void stop() {
        canWork = false;
    }
}

№2 volatile - запрещает потоку кешировать переменную и заставляет читать ее из общей памяти.
class Exemple {
    boolean volatile canWork = true;
    
    public void doWork() {
        if(canWork) {}
    }
    
    public void stop() {
        canWork = false;
    }
}
==========
Lock object - Critical Section
Таким образом мы ограничили кол-во потоков которые могут при помощи up() инкрементировать i.
class Exemple {
    int i  = 1;
    Object obj = new Object();
    
    public void up() {
        synchronized(obj) {
            i++;
        }
    }
}
==========
Deadlock
два потока ждут друг-друга
==========
Служба в отдельном потоке:
public void run() {
    while(true) {
        if(doSomethind) {
            //....
        }
        Thread.sleep(1000);
    }
}
===========
Как работает блокировка:
Несколько потоков подходят к критической секции.
Один из них начинет работу остальные встают в очередь. Что-бы свтать в очередь потоки вызывают на объекте монитора метод wait() 
Когда поток выходит из критической секции, он вызывает у объекта-монитора метод notify() и пробуждает последний поток стоящий в очерди.(Будит это сигнал в OC)
===========

JMM
В heap храняться все переменные которые используются в программе.

Thread Stack это локальный кэш который используется для потока. Все переменные которые будут в нем храниться будут доступны только этому потоку.

===================================================================================
========================================ВОПРОСЫ===================================
===================================================================================
1. Чем отличается процесс от потока?
О: Процесс это Отдельно запущенное приложение и у него есть своя область памяти.(минимум 1 поток)
=======
Поток это паралельные нити выполнения внутри одного процесса которые разделяют общую память.
Поток это объект у которого есть 2 метода:
1)start(); вызывается другим потоком. У этого объекта будет выполнен метод run(); паралельно с тем потоком который вызвал метод  start();
===================================================================================
2. Каким образом можно создать поток? new Thread(); new Callable(); new Runnuble(); 
О: Создать объект new Callable(); или new Runnuble(); и отправить аргументом в new Thread();
либо ExecutorServise.submit(...)  но это тоже самое только оптом.
Способ_1 : new Thread(new Runnuble(){...});
Способ_2 : executorService.submit(Runnuble(){...} || Callable(){...});
вернется new Future<?>.

Способ_3 : executorService.excute(Runnuble(){...});
Способ_4 : new Timer().schedule(new TimerTask() {...});
===================================================================================
3. Как работают методы sleep, yield, wait, notify и notifyAll?
sleep - усыпляет поток, не освобождает lock объект
wait - усыпляет поток, освобождает lock объект
notify - будит последний стоящий в очереди поток
notifyAll - будит все стоящие в очереди объекты
yield - это попытка усткпить очередь потокам, решает jvm.
===================================================================================
4. Объясните следующие термины: монитор, мьютекс, критическая секция.
монитор - объект который следит сколько потоков исполняет критическую секцию
критическая секция - код который может выполняться только одним потоком
мьютекс - двоичный симафор
===================================================================================
5. Как работает join()?
===================================================================================
6. Что такое DeadLock? Приведите примеры.
===================================================================================
7. Назовите различия между Collections.synchronizedMap(new HashMap()) и ConcurrentHashMap.
===================================================================================
8. Различия в интерфейсах Runnable и Callable.
===================================================================================
9. Различя между isInterrupted(), interrupted().
===================================================================================
10. Что происходит при вызове Thread.interrupt()?
===================================================================================
11. Перечислите ВСЕ причины по которым может выскочить InterruptedException.
если вызвать interrupt() когда поток wait или sleep
При вызове new Tread.join(), new Future.get()
При вызове sleep() и wait();
Когда блокируем объект при помощи ReentrantLock();
При блокировки при помощи симафора SEMAPHORE.acquire(), SEMAPHORE.release();
При new CyclicBarrier(3, new FerryBoat())await();

===================================================================================
12. Назовите отличия synchronize{} и ReentrantLock.
ReentrantLock - на много более производительный 
===================================================================================
13. Приведите наиболее существенное отличие между CountDownLatch и Barrier.
Barrier многоразовый а CountDownLatch используется только один раз.
===================================================================================
14. Отличие Thread.start() и Thread.run()?
start вызывает run и мы не знаем когда точно.
===================================================================================
15. Объясните ключевое слово volatile.
Запрещает кэшировать процессорам работу с переменной решает проблему vizabylity.
===================================================================================
16. Расскажите про приоритеты потока.
Приоритет выставляет ОС попытки влиять в рамках JVM не дают гарантированного результата.
===================================================================================
17. Что такое потоки-демоны?
Это поток который завершается вместе с main
===================================================================================
18. Назовите все возможные состояния потока.
не start, start, wait||sleep, отработал. На любом этапе может быть вызван interrupt()
===================================================================================
19. Что такое race condition?
проблема атомарности 
===================================================================================
20. Что такое Thread Local переменная? 
переменная которая видна только в рамках потока
===================================================================================
21. Что такое FutureTask????????????????????????

===================================================================================
22. Что такое Thread Pool?
Объект который инкапсулирует работу нескольких потоков.
===================================================================================
23. Что такое Semaphore?
сколько одновременно потоков может войти в критическую секцию
===================================================================================
24. Чем отличается submit от execute у ExecutorServices?
submit это люертка для execute добавляет возвращаемое объект Futur.
===================================================================================
25. Чем отличается shutdown от shutdownNow у ThreadPoolExecutor?
===================================================================================
27. Как создать ThreadPool у ExecutorService только на 1, на 5, на неограниченное количество 
потоков.
Executors.newSingleThreadExecutor();
Executors.newFixedThreadPool(3);
===================================================================================
28. Что такое ReadWriteLock?
много читателей и один писатель
===================================================================================
29. В чём отличие Thread от FutureTask(имеет возвр.знач.)? В чём отличие Thread.interrupt() и 
FutureTask.cancel().
interrupt() - перставляет флаг, а cancel()
===================================================================================
30. Расскажите про шаблон проектирования Producer Consumer.
Когда у нас несколько поставщико и несколько потребителей данных, каждый в отдельном потоке,
мы организуем их взаимодействие через LinkedBlockingQueue() у которой есть метод poll() который принимает в качестве рараметра время которое она готова ждать до того как сдаться.





