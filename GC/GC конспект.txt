GC

1. Модель работы Serial. Ключь: -XX:+UseSerialGC
Предполагает использование одного процессора. 
Весь процесс в одном потоке.
1.1 Помеченный объект попадает в контейнер Yong Generation
1.2 Если какие-то объкты выжили в Yong Generation, то попадает в
контейнер Survivor Spaces, который состоит из 2 частей "From" и "To". 
Сначала в From если кто-то выжил то он пападает в To. Если в To кто-то выжил,
он попадает в контейнер Old Generation

2. Модель работы Parallel. Ключь: -XX:+UseParallelGC
Проедполагает использование нескольких процессоров, как результат выйгрыш в производительности,
но при этом затрачивается больше ресурсов. Работает как и Serial только в паралельных потоках
соответственно быстрее.

3. Parallel Compacting Collector Работает так же как Parallel, но после высвобождения памяти, использует алгоритм Compaction(сжатие ячеек в нерпирывный ряд).
Клчь: -XX:+UseParalleOldGC

4. Concurrent Mark Sweep Copmact Collector. Ключь: -XX:+UseConcMarkSweepGC.
Имеет самый меньший Stop The World Pause - быстрый отклик приложения.


Алгоритмы сбора мусора. (Просто алгоритмы может использоваться и в Serial и в Parallel)

Поблоковый-паралельный режим Concurrent
1. Помечаем все объекты которые не имеют ссылок.
2. Помеченные переносятся в Yong Generation туда попадают локальные переменные 
3. Проверка точно ли все эти обекты надо удалить 
4. Высвобождение памяти.
В целом процесс получается дольше но нет состояний где мы блокируем состояние программы.


Остановка всего приложения. Алгоритм Stop the world.
1. Останавливаем выполнение программы и проверяем какие объекты не имеют внешних ссылок,
и удаляем их.

Два варианта алгоритма после того как мы очистили память. (После!!!)
Олгаритм Compaction 
1. Удаление объектов без ссылок.
2. Сжатие ячеек в один неприрывный ряд. (Типо дефрагминтации)


Олгаритм Non-Compaction 
1. Удаление объектов без ссылок. Без сжатия, накладывает дополнительные
издержки на последующую запись в эти ячейки памяти.


Олгаритм Copying
1. Удаляем не нужные объекты, и вместо сжатия копируем уже имеющиеся объекты 
в свободные ячейки.

Разница между Copying и Compaction???

Ключи:
1) Xmx?m (на месте вопроса колличество Мб = максимальный размер хипа для программы(default = 256Mb)) После превышения OutOfMemoryError.
2) Xms?m (кол-во Кб которое реально используется для хипа, когда программа работает, default=64Kb. JVM делает инкремент этого значения пока оно != Xmx?m.
3)

===========================================
Есть 2 типа сборщиков
1) -client (serial GC(Xmx64m, Xms4m)) (хорошо для однопоточных приложений увеличивает время отклика)
2) -server от 32Mb до 2Gb

Утилиты
Процесс выполнения каждой программы имеет свой индетификатор
1) jps выводит все процессы которые использует VM
2) jmap -heap 4290 получить информацию о памяти по индетификатору процесса


==========================================
Типы ссылок:

1)Strong Reference: A a = new A(); Обнуляется когда доступ к объекту потерян.
2)WeakReference - Слабая ссылка.
Для нее есть обертка:
WeakReference<Counter> weak = new WeakReference<Counter>(counter);
Можно получить доступ пока не вызовется GC но по скольку не извесно когда это произойдет,
такой тип ссылок - не стабильный. Не использовать.!!
3)SoftReference - GC уничножает объект только в том случае если у него не хватает памяти.
Counter counter = new Counter();
SoftReference soft = new SoftReferense(counter);
================================================================================
=================================/ ЭКЗАМЕН \===================================
================================================================================

1. Чем java отличается от с++?
О: В java gc работет автоматически и ультимативно вызвать его нельзя. Есть только возможность
вызвыть метод system.gc() но не факт что он сработает. Последнее слово за jvm.
================================================================================

2. Что такое менеджер памяти?
О: Это механизм упавления памятью который следит за тем что-бы объекты на которые нет ссылок
из main() были удалены из памяти.

================================================================================

3. Какой механизм используется в Java для управления памятью?
О: Есть начальное значение размера heap, тоесть память доступная программе, и это значение
инкрементируется пока не достигнет максимально установленного для данной программы. После чего
gc либо находит данные которые можно удалить либо программа падает c OutOfMemoryError.
Размер heap по умолчанию 256Мб, его можно изменить при помощи ключа Xmx...m
Начальное значение используемой памяти при старте 64 Кb. Его можно изменить ключем Xms..m

================================================================================

4. Опишите процесс работы сборщика мусора?

1. Модель работы Serial. Ключь: -XX:+UseSerialGC
Предполагает использование одного процессора. 
Весь процесс в одном потоке.
1.1 Помеченный объект попадает в контейнер Yong Generation
1.2 Если какие-то объкты выжили в Yong Generation, то попадает в
контейнер Survivor Spaces, который состоит из 2 частей "From" и "To". 
Сначала в From если кто-то выжил то он пападает в To. Если в To кто-то выжил,
он попадает в контейнер Old Generation

2. Модель работы Parallel. Ключь: -XX:+UseParallelGC
Проедполагает использование нескольких процессоров, как результат выйгрыш в производительности,
но при этом затрачивается больше ресурсов. Работает как и Serial только в паралельных потоках
соответственно быстрее.

3. Parallel Compacting Collector Работает так же как Parallel, но после высвобождения памяти, использует алгоритм Compaction(сжатие ячеек в нерпирывный ряд).
Клчь: -XX:+UseParalleOldGC

4. Concurrent Mark Sweep Copmact Collector. Ключь: -XX:+UseConcMarkSweepGC.
Имеет самый меньший Stop The World Pause - быстрый отклик приложения.


================================================================================

5. Какие алгоритмы сборщика вы знаете?

Поблоковый-паралельный режим Concurrent
1. Помечаем все объекты которые не имеют ссылок.
2. Помеченные переносятся в Yong Generation туда попадают локальные переменные 
3. Проверка точно ли все эти обекты надо удалить 
4. Высвобождение памяти.
В целом процесс получается дольше но нет состояний где мы блокируем состояние программы.


Остановка всего приложения. Алгоритм Stop the world.
1. Останавливаем выполнение программы и проверяем какие объекты не имеют внешних ссылок,
и удаляем их.

Два варианта алгоритма после того как мы очистили память. (После!!!)
Олгаритм Compaction 
1. Удаление объектов без ссылок.
2. Сжатие ячеек в один неприрывный ряд. (Типо дефрагминтации)


Олгаритм Non-Compaction 
1. Удаление объектов без ссылок. Без сжатия, накладывает дополнительные
издержки на последующую запись в эти ячейки памяти.


Олгаритм Copying
1. Удаляем не нужные объекты, и вместо сжатия копируем уже имеющиеся объекты 
в свободные ячейки.

================================================================================

6. Чем отличаются сборщики мусора?

Есть 2 типа сборщиков
1) -client (serial GC(Xmx64m, Xms4m)) (хорошо для однопоточных приложений увеличивает время отклика)
2) -server от 32Mb до 2Gb


================================================================================

7. Расскажите про утилиты для анализа памяти?
Утилиты
Процесс выполнения каждой программы имеет свой индетификатор
1) jps выводит все процессы которые использует VM
2) jmap -heap 4290 получить информацию о памяти по индетификатору процесса

================================================================================

8. Какие типы ссылок вы знаете?

Типы ссылок:

1)Strong Reference: A a = new A(); Обнуляется когда доступ к объекту потерян.
2)WeakReference - Слабая ссылка.
Для нее есть обертка:
WeakReference<Counter> weak = new WeakReference<Counter>(counter);
Можно получить доступ пока не вызовется GC но по скольку не извесно когда это произойдет,
такой тип ссылок - не стабильный. Не использовать.!!
3)SoftReference - GC уничножает объект только в том случае если у него не хватает памяти.
Counter counter = new Counter();
SoftReference soft = new SoftReferense(counter);
















